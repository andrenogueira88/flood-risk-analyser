# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FloodRiskAnalyzerDialog
                                 A QGIS plugin
 FloodRisk Analyzer: QGIS Plugin for Flood Risk Classification
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Andre Nogueira Sousa
        email                : andrenogsousa@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox, QTableWidgetItem
from qgis.core import QgsRasterLayer, QgsMessageLog, Qgis

import os
import pandas as pd
import numpy as np
from osgeo import gdal

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'flood_risk_dialog_base.ui'))


class FloodRiskAnalyzerDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(FloodRiskAnalyzerDialog, self).__init__(parent)
        self.setupUi(self)
        
        # Initialize file dictionary to store file paths and their types
        self.files_dict = {}
        
        # Connect signals with correct UI element names
        self.addItem.clicked.connect(self.add_file)
        self.removeItem.clicked.connect(self.remove_file)
        self.comboBox.currentIndexChanged.connect(self.update_file_type)
        
        # Add selection change handler
        self.fileListWidget.itemSelectionChanged.connect(self.on_selection_change)

        # Add connection for process button
        self.processDataFrame.clicked.connect(self.process_dataframe)

    def add_file(self):
        """Open file dialog and add selected file to list"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Input File",
            "",
            "All Files (*.*);;Raster Files (*.tif *.img);;Vector Files (*.shp)"
        )

        if file_path:
            # Add file to list widget
            file_name = os.path.basename(file_path)
            self.fileListWidget.addItem(file_name)

            # Store full path and initial type (use 'Continuous' instead of 'float')
            self.files_dict[file_name] = {
                'path': file_path,
                'type': 'Continuous'  # Changed from 'float' to match comboBox options
            }

    def remove_file(self):
        """Remove selected file from list"""
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            # Remove from dictionary
            if file_name in self.files_dict:
                del self.files_dict[file_name]
            # Remove from list widget
            self.fileListWidget.takeItem(self.fileListWidget.row(current_item))

    def update_file_type(self):
        """Update the type of the currently selected file"""
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            new_type = self.comboBox.currentText()
            if file_name in self.files_dict:
                self.files_dict[file_name]['type'] = new_type

    def on_selection_change(self):
        """Update combo box when list selection changes"""
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            if file_name in self.files_dict:
                # Set combo box to current file type
                current_type = self.files_dict[file_name]['type']
                index = self.comboBox.findText(current_type)
                if index >= 0:
                    self.comboBox.setCurrentIndex(index)

    def get_files_data(self):
        """Return the dictionary of files and their types"""
        return self.files_dict

    def raster_to_dataframe(self, raster_layer, column_name):
        """
        Converts a raster layer to a pandas DataFrame with pixel values and their corresponding spatial coordinates.

        Parameters:
            raster_layer (QgsRasterLayer): The raster layer to convert.

        Returns:
            pandas.DataFrame: A DataFrame with columns:
                - 'value': The raster pixel value (with NoData replaced by np.nan).
                - 'x': The x-coordinate of the pixel center.
                - 'y': The y-coordinate of the pixel center.
        """
        
        provider = raster_layer.dataProvider()
        nodata = provider.sourceNoDataValue(1)

        extent = raster_layer.extent()
        width = raster_layer.width()
        height = raster_layer.height()
        block = provider.block(1, extent, width, height)

        array_2d = np.array(
            [[block.value(x, y) for x in range(width)] for y in range(height)]
        )

        flat_array = array_2d.flatten()

        if nodata is not None:
            flat_array = np.where(np.isclose(flat_array, nodata), np.nan, flat_array)

        x_origin = extent.xMinimum()
        y_origin = extent.yMaximum()
        pixel_width = raster_layer.rasterUnitsPerPixelX()
        pixel_height = raster_layer.rasterUnitsPerPixelY()

        x_coords = np.array(
            [x_origin + (i % width) * pixel_width for i in range(width * height)]
        )

        y_coords = np.array(
            [y_origin - (i // width) * pixel_height for i in range(width * height)]
        )

        df = pd.DataFrame({column_name: flat_array, "x": x_coords, "y": y_coords})


        return df

    def process_dataframe(self):
        """Process all files into a unified dataframe"""
        # Group files by type
        files_by_type = {'Continuous': [], 'Categorical': [], 'Binary': [], 'Target': []}
        for file_name, file_info in self.files_dict.items():
            files_by_type[file_info['type']].append(file_info['path'])

        # Validate target file
        if len(files_by_type['Target']) != 1:
            QMessageBox.critical(self, "Error", "Exactly one target file must be specified")
            return

        # Check CRS and resolution matching
        raster_layers = {}
        reference_layer = None
        
        for file_type, file_paths in files_by_type.items():
            for file_path in file_paths:
                layer = QgsRasterLayer(file_path, os.path.basename(file_path))
                if not layer.isValid():
                    QMessageBox.critical(self, "Error", f"Invalid raster layer: {file_path}")
                    return
                
                if reference_layer is None:
                    reference_layer = layer
                else:
                    # Check CRS matching
                    if layer.crs() != reference_layer.crs():
                        QMessageBox.critical(self, "Error", 
                            f"CRS mismatch between {file_path} and reference layer")
                        return
                    
                    # Check resolution matching
                    if layer.rasterUnitsPerPixelX() != reference_layer.rasterUnitsPerPixelX():
                        QMessageBox.critical(self, "Error", 
                            f"Resolution mismatch between {file_path} and reference layer")
                        return
                
                raster_layers[file_path] = layer

        # Convert rasters to dataframe with coordinates
        dataframes = []
        features = []
        
        for file_type, file_paths in files_by_type.items():
            for file_path in file_paths:
                # Read raster data using QGIS provider (similar to main.py)
                column_name = os.path.basename(file_path).replace('.tif', '')
                layer = raster_layers[file_path]
                df = self.raster_to_dataframe(layer, column_name)

                
                if file_type == 'Categorical':
                    print("Categorical Processing")
                    # Apply one-hot encoding
                    one_hot = pd.get_dummies(df[column_name], prefix=column_name)
                    # Add coordinates to one-hot encoded data
                    one_hot_with_coords = pd.concat([df[['x', 'y']], one_hot], axis=1)
                    dataframes.append(one_hot_with_coords)
                    dataframes.append(df)
                    features.extend(one_hot.columns.tolist())
                    features.append(column_name)
                elif file_type == 'Binary':
                    print("Binary Processing")
                    df[column_name] = df[column_name].replace({True: 1, False: 0})
                    dataframes.append(df)
                    features.append(column_name)
                elif file_type == 'Target':
                    print("Target Processing")
                    df[column_name] = df[column_name].replace({True: 1, False: 0})
                    # if not set(df[column_name].unique()).issubset({0, 1}):
                    #     QMessageBox.critical(self, "Error", "Target must be binary (0/1)")
                    #     return
                    target_name = column_name
                    dataframes.append(df)
                    features.append(column_name)
                else:  # Continuous
                    print("Continuous Processing")
                    dataframes.append(df)
                    features.append(column_name)

        # Merge dataframes by coordinates instead of concatenating
        if dataframes:
            final_df = dataframes[0]
            for df in dataframes[1:]:
                final_df = pd.merge(final_df, df, on=['x', 'y'], how='outer')
        else:
            QMessageBox.critical(self, "Error", "No dataframes to process")
            return

        QgsMessageLog.logMessage(f"{final_df.columns.tolist()}")
        final_df[target_name] = final_df[target_name].fillna(0)

        # Update statistics before saving
        final_df.dropna(subset=features, how='any', inplace=True)
        self.update_statistics_tables(final_df)
        
        # Save processed dataframe
        output_path = os.path.join(os.path.dirname(list(files_by_type.values())[0][0]), 'processed_data.parquet')
        final_df.to_parquet(output_path)
        QMessageBox.information(self, "Success", 
            f"Data processed successfully and saved to {output_path}")

    def update_statistics_tables(self, df):
        """Update all statistics tables with DataFrame information"""
        # Get column types based on original file types
        continuous_cols = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                        if info['type'] == 'Continuous']
        categorical_cols = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                        if info['type'] == 'Categorical']
        target_col = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                    if info['type'] == 'Target'][0]

        # 1. Continuous Features Statistics
        cont_stats = df[continuous_cols].describe()
        self.contDist.setRowCount(4)  # mean, std, min, max
        self.contDist.setColumnCount(len(continuous_cols))
        
        # Set headers
        self.contDist.setHorizontalHeaderLabels(continuous_cols)
        self.contDist.setVerticalHeaderLabels(['Mean', 'Std', 'Min', 'Max'])
        
        # Fill data
        for col_idx, col in enumerate(continuous_cols):
            self.contDist.setItem(0, col_idx, QTableWidgetItem(f"{cont_stats[col]['mean']:.2f}"))
            self.contDist.setItem(1, col_idx, QTableWidgetItem(f"{cont_stats[col]['std']:.2f}"))
            self.contDist.setItem(2, col_idx, QTableWidgetItem(f"{cont_stats[col]['min']:.2f}"))
            self.contDist.setItem(3, col_idx, QTableWidgetItem(f"{cont_stats[col]['max']:.2f}"))


        # 2. Categorical Features
        self.catFeat.clear()
        for col in categorical_cols:
            df[col] = df[col].astype(str)
            unique_vals = df[col].unique()
            self.catFeat.addItem(f"{col}: {len(unique_vals)} unique values")
            for val in unique_vals:
                count = df[col].value_counts()[val]
                self.catFeat.addItem(f"    {val}: {count} samples")

        # 3. Target Distribution
        target_dist = df[target_col].value_counts()
        total_samples = len(df)
        
        self.targetDist.clear()
        self.targetDist.addItem(f"Total Samples: {total_samples}")
        for class_val, count in target_dist.items():
            percentage = (count / total_samples) * 100
            self.targetDist.addItem(f"Class {class_val}: {count} samples ({percentage:.2f}%)")
