# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FloodRiskAnalyzerDialog
                                 A QGIS plugin
 FloodRisk Analyzer: QGIS Plugin for Flood Risk Classification
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Andre Nogueira Sousa
        email                : andrenogsousa@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from sklearn.feature_selection import (
    SelectKBest, f_classif, mutual_info_classif,
    RFE, SelectFromModel
)
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report
from qgis.PyQt.QtCore import QAbstractTableModel, Qt, QVariant
from qgis.PyQt.QtWidgets import QTableWidgetItem

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox, QTableWidgetItem
from qgis.core import QgsRasterLayer, QgsMessageLog, Qgis

import os
import pandas as pd
import numpy as np
from osgeo import gdal

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'flood_risk_dialog_base.ui'))

class FeatureImportanceModel(QAbstractTableModel):
    """
    Custom table model for displaying feature importance results in a QTableView.
    
    This model provides a structured way to display feature selection results
    including rank, feature name, importance score, and selection status.
    
    Attributes:
        _data (list): Internal storage for table data as list of rows
        _headers (list): Column headers for the table
    """
    
    def __init__(self, data=None):
        """
        Initialize the FeatureImportanceModel.
        
        Args:
            data (list, optional): Initial data for the table. Defaults to None.
        """
        super().__init__()
        self._data = data or []
        self._headers = ['Rank', 'Feature Name', 'Importance Score']
    
    def data(self, index, role):
        """
        Return data for a given table cell based on index and role.
        
        Args:
            index (QModelIndex): The model index specifying row and column
            role (int): The Qt role (e.g., DisplayRole, EditRole)
            
        Returns:
            QVariant: The data for the specified cell, or QVariant() if invalid
        """
        if role == Qt.DisplayRole:
            return str(self._data[index.row()][index.column()])
        return QVariant()
    
    def rowCount(self, index):
        """
        Return the number of rows in the model.
        
        Args:
            index (QModelIndex): Parent model index (unused for table model)
            
        Returns:
            int: Number of rows in the data
        """
        return len(self._data)
    
    def columnCount(self, index):
        """
        Return the number of columns in the model.
        
        Args:
            index (QModelIndex): Parent model index (unused for table model)
            
        Returns:
            int: Number of columns (headers)
        """
        return len(self._headers)
    
    def headerData(self, section, orientation, role):
        """
        Return header data for the specified section and orientation.
        
        Args:
            section (int): The section number (column or row index)
            orientation (Qt.Orientation): Horizontal or vertical orientation
            role (int): The Qt role
            
        Returns:
            QVariant: Header label or QVariant() if invalid
        """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self._headers[section]
        return QVariant()
    
    def update_data(self, data):
        """
        Update the model with new data and notify views.
        
        Args:
            data (list): New data as list of rows to replace current data
        """
        self.beginResetModel()
        self._data = data
        self.endResetModel()

class FloodRiskAnalyzerDialog(QtWidgets.QDialog, FORM_CLASS):
    """
    Main dialog class for the Flood Risk Analyzer QGIS plugin.
    
    This dialog provides a user interface for:
    - Loading and managing raster files for flood risk analysis
    - Processing multiple raster layers into a unified DataFrame
    - Performing feature selection using various machine learning methods
    - Displaying statistics and feature importance results
    
    Attributes:
        files_dict (dict): Dictionary storing file paths and types
        processed_df (pd.DataFrame): Processed and merged DataFrame from all rasters
        selected_features (list): List of selected feature names after feature selection
        current_method (str): Currently selected feature selection method
        feature_model (FeatureImportanceModel): Model for displaying feature results
    """
    def __init__(self, parent=None):
        """
        Initialize the FloodRiskAnalyzerDialog.
        
        Sets up the UI components, initializes data structures, and connects
        signal handlers for user interactions.
        
        Args:
            parent (QWidget, optional): Parent widget. Defaults to None.
        """
        super(FloodRiskAnalyzerDialog, self).__init__(parent)
        self.setupUi(self)

        self.files_dict = {}
        self.processed_df = None
        self.selected_features = []
        self.current_method = None

        self.feature_model = FeatureImportanceModel()
        self.featImpValues.setModel(self.feature_model)

        self.addItem.clicked.connect(self.add_file)
        self.removeItem.clicked.connect(self.remove_file)
        self.comboBox.currentIndexChanged.connect(self.update_file_type)
        self.fileListWidget.itemSelectionChanged.connect(self.on_selection_change)
        self.processDataFrame.clicked.connect(self.process_dataframe)

        self.featImpCalc.clicked.connect(self.calculate_feature_importance)
        self.MethodsList.itemClicked.connect(self.on_method_selected)

        self.setup_methods_list()

        self.addItem.clicked.connect(self.add_file)
        self.removeItem.clicked.connect(self.remove_file)
        self.comboBox.currentIndexChanged.connect(self.update_file_type)

        self.fileListWidget.itemSelectionChanged.connect(self.on_selection_change)

        self.processDataFrame.clicked.connect(self.process_dataframe)

    def add_file(self):
        """
        Open a file dialog to select and add a raster file to the analysis.
        
        Opens a file dialog allowing the user to select raster files (TIF, IMG)
        or vector files (SHP). The selected file is added to the file list widget
        and stored in the files dictionary with default 'Continuous' type.
        """
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Input File",
            "",
            "All Files (*.*);;Raster Files (*.tif *.img);;Vector Files (*.shp)"
        )

        if file_path:
            file_name = os.path.basename(file_path)
            self.fileListWidget.addItem(file_name)

            self.files_dict[file_name] = {
                'path': file_path,
                'type': 'Continuous'
            }

    def remove_file(self):
        """
        Remove the currently selected file from the file list and dictionary.
        
        Removes both the visual representation in the list widget and the
        corresponding entry in the files dictionary.
        """
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            if file_name in self.files_dict:
                del self.files_dict[file_name]
            self.fileListWidget.takeItem(self.fileListWidget.row(current_item))

    def update_file_type(self):
        """
        Update the data type of the currently selected file.
        
        Changes the type (Continuous, Categorical, Binary, Target) of the
        selected file based on the current combo box selection.
        """
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            new_type = self.comboBox.currentText()
            if file_name in self.files_dict:
                self.files_dict[file_name]['type'] = new_type

    def on_selection_change(self):
        """
        Handle file list selection changes.
        
        Updates the combo box to show the current type of the selected file
        when the user clicks on a different file in the list.
        """
        current_item = self.fileListWidget.currentItem()
        if current_item:
            file_name = current_item.text()
            if file_name in self.files_dict:
                current_type = self.files_dict[file_name]['type']
                index = self.comboBox.findText(current_type)
                if index >= 0:
                    self.comboBox.setCurrentIndex(index)

    def get_files_data(self):
        """
        Get the dictionary of files and their assigned types.
        
        Returns:
            dict: Dictionary with file names as keys and file info (path, type) as values
        """
        return self.files_dict

    def raster_to_dataframe(self, raster_layer, column_name):
        """
        Convert a QGIS raster layer to a pandas DataFrame with spatial coordinates.

        Extracts pixel values from a raster layer and creates a DataFrame containing
        the pixel values along with their corresponding x, y coordinates. NoData
        values are converted to NaN for proper handling in pandas.

        Args:
            raster_layer (QgsRasterLayer): The QGIS raster layer to convert
            column_name (str): Name for the column containing pixel values

        Returns:
            pd.DataFrame: DataFrame with columns:
                - column_name: The raster pixel values (NoData replaced with np.nan)
                - 'x': X-coordinate of pixel center
                - 'y': Y-coordinate of pixel center
        """
        
        provider = raster_layer.dataProvider()
        nodata = provider.sourceNoDataValue(1)

        extent = raster_layer.extent()
        width = raster_layer.width()
        height = raster_layer.height()
        block = provider.block(1, extent, width, height)

        array_2d = np.array(
            [[block.value(x, y) for x in range(width)] for y in range(height)]
        )

        flat_array = array_2d.flatten()

        if nodata is not None:
            flat_array = np.where(np.isclose(flat_array, nodata), np.nan, flat_array)

        x_origin = extent.xMinimum()
        y_origin = extent.yMaximum()
        pixel_width = raster_layer.rasterUnitsPerPixelX()
        pixel_height = raster_layer.rasterUnitsPerPixelY()

        x_coords = np.array(
            [x_origin + (i % width) * pixel_width for i in range(width * height)]
        )

        y_coords = np.array(
            [y_origin - (i // width) * pixel_height for i in range(width * height)]
        )

        df = pd.DataFrame({column_name: flat_array, "x": x_coords, "y": y_coords})


        return df

    def process_dataframe(self):
        """
        Process all loaded raster files into a unified DataFrame for analysis.
        
        This method:
        1. Validates that exactly one target file is specified
        2. Loads all raster files and checks for CRS and resolution compatibility
        3. Converts rasters to DataFrames based on their assigned types:
           - Continuous: Direct conversion
           - Categorical: One-hot encoding
           - Binary: Boolean to 0/1 conversion
           - Target: Boolean to 0/1 conversion
        4. Merges all DataFrames on spatial coordinates (x, y)
        5. Updates statistics tables in the UI
        6. Saves processed data to Parquet format
        7. Enables feature selection functionality
        
        Raises:
            Critical error dialogs for various validation failures including:
            - Invalid number of target files
            - Invalid raster layers
            - CRS mismatches between layers
            - Resolution mismatches between layers
        """
        files_by_type = {'Continuous': [], 'Categorical': [], 'Binary': [], 'Target': []}
        for file_name, file_info in self.files_dict.items():
            files_by_type[file_info['type']].append(file_info['path'])

        if len(files_by_type['Target']) != 1:
            QMessageBox.critical(self, "Error", "Exactly one target file must be specified")
            return

        raster_layers = {}
        reference_layer = None
        
        for file_type, file_paths in files_by_type.items():
            for file_path in file_paths:
                layer = QgsRasterLayer(file_path, os.path.basename(file_path))
                if not layer.isValid():
                    QMessageBox.critical(self, "Error", f"Invalid raster layer: {file_path}")
                    return
                
                if reference_layer is None:
                    reference_layer = layer
                else:
                    if layer.crs() != reference_layer.crs():
                        QMessageBox.critical(self, "Error", 
                            f"CRS mismatch between {file_path} and reference layer")
                        return

                    if layer.rasterUnitsPerPixelX() != reference_layer.rasterUnitsPerPixelX():
                        QMessageBox.critical(self, "Error", 
                            f"Resolution mismatch between {file_path} and reference layer")
                        return
                
                raster_layers[file_path] = layer

        dataframes = []
        features = []
        
        for file_type, file_paths in files_by_type.items():
            for file_path in file_paths:
                column_name = os.path.basename(file_path).replace('.tif', '')
                layer = raster_layers[file_path]
                df = self.raster_to_dataframe(layer, column_name)

                
                if file_type == 'Categorical':
                    print("Categorical Processing")
                    one_hot = pd.get_dummies(df[column_name], prefix=column_name)
                    one_hot_with_coords = pd.concat([df[['x', 'y']], one_hot], axis=1)
                    dataframes.append(one_hot_with_coords)
                    dataframes.append(df)
                    features.extend(one_hot.columns.tolist())
                    features.append(column_name)
                elif file_type == 'Binary':
                    print("Binary Processing")
                    df[column_name] = df[column_name].replace({True: 1, False: 0})
                    dataframes.append(df)
                    features.append(column_name)
                elif file_type == 'Target':
                    print("Target Processing")
                    df[column_name] = df[column_name].replace({True: 1, False: 0})
                    target_name = column_name
                    dataframes.append(df)
                    features.append(column_name)
                else:
                    print("Continuous Processing")
                    dataframes.append(df)
                    features.append(column_name)

        if dataframes:
            final_df = dataframes[0]
            for df in dataframes[1:]:
                final_df = pd.merge(final_df, df, on=['x', 'y'], how='outer')
        else:
            QMessageBox.critical(self, "Error", "No dataframes to process")
            return

        QgsMessageLog.logMessage(f"{final_df.columns.tolist()}")
        final_df[target_name] = final_df[target_name].fillna(0)

        self.processed_df = final_df.copy()

        final_df.dropna(subset=features, how='any', inplace=True)
        self.update_statistics_tables(final_df)

        self.enable_feature_selection()

        output_path = os.path.join(os.path.dirname(list(files_by_type.values())[0][0]), 'processed_data.parquet')
        final_df.to_parquet(output_path)
        QMessageBox.information(self, "Success", 
             f"Data processed successfully and saved to {output_path}\n\nFeature Selection tab is now ready!")

    def update_statistics_tables(self, df):
        """
        Update all statistics display tables with DataFrame information.
        
        Populates the UI statistics tables with:
        - Continuous features: descriptive statistics (mean, std, min, max)
        - Categorical features: unique values and their counts
        - Target distribution: class balance information
        
        Args:
            df (pd.DataFrame): The processed DataFrame containing all features
        """
        continuous_cols = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                        if info['type'] == 'Continuous']
        categorical_cols = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                        if info['type'] == 'Categorical']
        target_col = [os.path.basename(path).replace('.tif', '') for path, info in self.files_dict.items() 
                    if info['type'] == 'Target'][0]

        cont_stats = df[continuous_cols].describe()
        self.contDist.setRowCount(4)
        self.contDist.setColumnCount(len(continuous_cols))
        
        self.contDist.setHorizontalHeaderLabels(continuous_cols)
        self.contDist.setVerticalHeaderLabels(['Mean', 'Std', 'Min', 'Max'])
        
        for col_idx, col in enumerate(continuous_cols):
            self.contDist.setItem(0, col_idx, QTableWidgetItem(f"{cont_stats[col]['mean']:.2f}"))
            self.contDist.setItem(1, col_idx, QTableWidgetItem(f"{cont_stats[col]['std']:.2f}"))
            self.contDist.setItem(2, col_idx, QTableWidgetItem(f"{cont_stats[col]['min']:.2f}"))
            self.contDist.setItem(3, col_idx, QTableWidgetItem(f"{cont_stats[col]['max']:.2f}"))

        self.catFeat.clear()
        for col in categorical_cols:
            df[col] = df[col].astype(str)
            unique_vals = df[col].unique()
            self.catFeat.addItem(f"{col}: {len(unique_vals)} unique values")
            for val in unique_vals:
                count = df[col].value_counts()[val]
                self.catFeat.addItem(f"    {val}: {count} samples")

        target_dist = df[target_col].value_counts()
        total_samples = len(df)
        
        self.targetDist.clear()
        self.targetDist.addItem(f"Total Samples: {total_samples}")
        for class_val, count in target_dist.items():
            percentage = (count / total_samples) * 100
            self.targetDist.addItem(f"Class {class_val}: {count} samples ({percentage:.2f}%)")


    def setup_methods_list(self):
        """
        Initialize the feature selection methods list widget.
        
        Populates the methods list with available feature importance techniques,
        each with a brief description of its characteristics and use cases.
        Sets the default selection to ANOVA F Test.
        """
        methods = [
            "ANOVA F Test - Statistical significance for continuous features", 
            "Mutual Information - Captures non-linear relationships",
            "Random Forest Importance - Handles feature interactions",
            "Permutation Importance - Model-agnostic feature importance",
            "L1 Regularization - Coefficient-based importance"
        ]
        
        self.MethodsList.clear()
        for method in methods:
            self.MethodsList.addItem(method)

        if methods:
            self.MethodsList.setCurrentRow(0)
            self.current_method = "ANOVA F Test"

    def on_method_selected(self, item):
        """
        Handle selection of a feature selection method from the list.
        
        Updates the current method and changes the button text to reflect
        the selected method.
        
        Args:
            item (QListWidgetItem): The selected list item containing method info
        """
        method_text = item.text()
        self.current_method = method_text.split(' - ')[0]

        self.featImpCalc.setText(f"Apply {self.current_method}")

    def enable_feature_selection(self):
        """
        Enable the feature selection functionality after data processing.
        
        Determines the maximum number of available features and enables
        the feature selection button with appropriate text indicating
        the selected method and number of features to select.
        """
        if self.processed_df is not None:
            feature_cols = [col for col in self.processed_df.columns 
                           if col not in ['x', 'y'] and not any(col.endswith(suffix) for suffix in 
                           [name.replace('.tif', '') for name, info in self.files_dict.items() if info['type'] == 'Target'])]
            
            max_features = len(feature_cols)
            
            self.featImpCalc.setText(f"Apply {self.current_method or 'ANOVA F Test'}")
            self.featImpCalc.setEnabled(True)

    def calculate_feature_importance(self):
        """
        Execute the selected feature selection method on the processed data.
        
        This method:
        1. Validates that data has been processed and a method is selected
        2. Prepares feature matrix (X) and target vector (y) from processed DataFrame
        3. Handles missing values by removing rows with NaN
        4. Applies the selected feature selection algorithm
        5. Displays results in the feature importance table
        6. Updates the selected features list
        
        The method supports five different feature selection approaches:
        - ANOVA F Test: Statistical test for continuous features
        - Mutual Information: Captures non-linear feature relationships
        - Random Forest Importance: Uses ensemble tree-based importance
        - Recursive Feature Elimination: Iterative backward selection
        - L1 Regularization: LASSO-based automatic selection
        
        Raises:
            Warning dialogs for missing prerequisites
            Critical error dialogs for processing failures
        """
        if self.processed_df is None:
            QMessageBox.warning(self, "Warning", "Please process the dataframe first in Tab 1")
            return

        if not self.current_method:
            QMessageBox.warning(self, "Warning", "Please select a method from the list")
            return
        
        try:
            target_col = None
            for file_name, file_info in self.files_dict.items():
                if file_info['type'] == 'Target':
                    target_col = os.path.basename(file_name).replace('.tif', '')
                    break
            
            if not target_col:
                QMessageBox.critical(self, "Error", "No target column found")
                return

            feature_cols = [col for col in self.processed_df.columns 
                           if col not in ['x', 'y', target_col]]
            
            X = self.processed_df[feature_cols].copy()
            y = self.processed_df[target_col].copy()

            mask = ~(X.isnull().any(axis=1) | y.isnull())
            X = X[mask]
            y = y[mask]
            
            if len(X) == 0:
                QMessageBox.critical(self, "Error", "No valid data after removing NaN values")
                return

            results = self.apply_feature_selection_method(X, y, feature_cols)
            
            if results:
                self.display_results(results)
                QMessageBox.information(self, "Success", 
                    f"Feature Importance Calculation completed using {self.current_method}!")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Feature Importance failed: {str(e)}")
            QgsMessageLog.logMessage(f"Feature Importance error: {str(e)}", level=Qgis.Critical)

    def apply_feature_selection_method(self, X, y, feature_cols):
        """
        Apply the specific feature importance calculation method to the data.
        
        Implements five different feature importance methods, each providing
        meaningful importance scores for all features without selection caps.
        
        Args:
            X (pd.DataFrame): Feature matrix with samples as rows and features as columns
            y (pd.Series): Target vector with class labels
            feature_cols (list): List of feature column names
            
        Returns:
            list: List of lists containing [rank, feature_name, score]
                for all features, sorted by importance score
                
        Raises:
            ValueError: If an unknown method is specified
        """
        from sklearn.inspection import permutation_importance
        
        if self.current_method == "ANOVA F Test":
            # Statistical test - higher F-scores indicate more important features
            selector = SelectKBest(f_classif, k='all')
            selector.fit(X, y)
            scores = selector.scores_
            
        elif self.current_method == "Mutual Information":
            # Information-theoretic measure - higher MI indicates stronger dependency
            selector = SelectKBest(mutual_info_classif, k='all')
            selector.fit(X, y)
            scores = selector.scores_
            
        elif self.current_method == "Random Forest Importance":
            # Tree-based feature importance - based on impurity reduction
            rf = RandomForestClassifier(n_estimators=100, random_state=42, 
                                    class_weight='balanced')
            rf.fit(X, y)
            scores = rf.feature_importances_
            
        elif self.current_method == "Permutation Importance":
            # Model-agnostic importance - based on performance drop when shuffled
            rf = RandomForestClassifier(n_estimators=50, random_state=42, 
                                    class_weight='balanced')
            rf.fit(X, y)
            perm_importance = permutation_importance(rf, X, y, n_repeats=5, 
                                                random_state=42)
            scores = perm_importance.importances_mean
            
        elif self.current_method == "L1 Regularization":
            # Linear model coefficients - absolute values indicate importance
            lasso = LogisticRegression(penalty='l1', solver='liblinear', 
                                    class_weight='balanced', random_state=42, 
                                    max_iter=1000)
            lasso.fit(X, y)
            scores = abs(lasso.coef_[0])
        
        else:
            raise ValueError(f"Unknown method: {self.current_method}")

        # Create results with all features ranked by importance
        results = []
        feature_score_pairs = list(zip(feature_cols, scores))
        
        # Sort by score (descending)
        feature_score_pairs.sort(key=lambda x: x[1], reverse=True)
        
        # Store all features as "selected" for display purposes
        self.selected_features = [name for name, score in feature_score_pairs]
        
        # Create ranked results
        for rank, (name, score) in enumerate(feature_score_pairs, 1):
            results.append([rank, name, f"{score:.4f}"])
        
        return results

    def display_results(self, results):
        """
        Display feature selection results in the table view.
        
        Updates the feature importance table model with new results and
        adjusts column widths for optimal display. Also updates the button
        text to indicate successful completion.
        
        Args:
            results (list): List of result rows containing rank, feature name,
                          importance score, and selection status
        """
        self.feature_model.update_data(results)
        
        self.featImpValues.resizeColumnsToContents()
        
        self.featImpCalc.setText(f"âœ“ {self.current_method} Applied - Select Different Method")
